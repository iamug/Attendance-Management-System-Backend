"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 *  expressweb-ioc
 *
 * (c) Alex Igbokwe <chukwuemekaigbokwe80@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Ioc {
    constructor() {
        this.entries = {};
    }
    isClass(fn, section, namespace) {
        if (typeof fn !== "function") {
            throw `Ioc.${section} expects 2nd parameter to be a closure in ${namespace}, ${fn}`;
        }
    }
    getAllFunction(value) {
        let props = [];
        let obj = value;
        do {
            props = props.concat(Object.getOwnPropertyNames(obj));
        } while ((obj = Object.getPrototypeOf(obj)));
        return props.sort().filter((e, i, arr) => {
            if (e != arr[i + 1] && typeof value[e] == "function")
                return true;
        });
    }
    componentScan(namespace) {
        if (this.entries[namespace]) {
            throw `${namespace} already exists in the application context`;
        }
    }
    register(namespace, instructions, mode) {
        this.componentScan(namespace);
        if (mode !== "value")
            this.isClass(instructions, "register", namespace);
        if (Object.keys(this.entries).length == 0) {
            this.entries[namespace] = {
                closure: instructions,
                singleton: false,
                cached: false,
                cachedValue: null,
                mode: mode,
                isProvider: false,
            };
        }
        else if (!this.entries[namespace]) {
            this.entries[namespace] = {
                closure: instructions,
                singleton: false,
                cached: false,
                cachedValue: null,
                mode: mode,
                isProvider: false,
            };
        }
    }
    asProvider(namespace, instructions, mode) {
        this.isClass(instructions, "asProvider");
        this.componentScan(namespace);
        if (Object.keys(this.entries).length == 0) {
            this.entries[namespace] = {
                closure: instructions,
                singleton: false,
                cached: false,
                cachedValue: null,
                mode: mode,
                isProvider: true,
            };
        }
        else if (this.entries[namespace] == null) {
            this.entries[namespace] = {
                closure: instructions,
                singleton: false,
                cached: false,
                cachedValue: null,
                mode: mode,
                isProvider: true,
            };
        }
        this.bootstrapServiceProvider(namespace);
    }
    bootstrapServiceProvider(namespace) {
        let serviceProvicer = this.entries[namespace].closure;
        let provider = new serviceProvicer();
        let methods = this.getAllFunction(provider);
        if (methods.includes("register"))
            provider.register();
    }
    singleton(namespace, instructions, mode) {
        this.isClass(instructions, "singleton");
        this.componentScan(namespace);
        let rules = {
            closure: instructions,
            singleton: true,
            cached: false,
            cachedValue: null,
            mode: mode,
            isProvider: false,
        };
        if (Object.keys(this.entries).length == 0) {
            this.entries[namespace] = {
                closure: null,
                singleton: true,
                cached: true,
                cachedValue: this.processInstrunction(rules),
                mode: mode,
                isProvider: false,
            };
        }
        else if (!this.entries[namespace]) {
            this.entries[namespace] = {
                closure: null,
                singleton: true,
                cached: true,
                cachedValue: this.processInstrunction(rules),
                mode: mode,
                isProvider: false,
            };
        }
        else if (this.entries[namespace] &&
            this.entries[namespace].cached == false) {
            this.entries[namespace].closure = null;
            this.entries[namespace].cached = true;
            this.entries[namespace].singleton = this.processInstrunction(rules);
        }
    }
    use(namespace) {
        const instructions = this.entries[namespace];
        if (instructions) {
            let response = this.resolveBinding(instructions);
            return response;
        }
    }
    resolveBinding(instructions) {
        if (instructions.singleton && instructions.cached) {
            return instructions.cachedValue;
        }
        else if (instructions.singleton) {
            instructions.cachedValue = instructions.closure(this);
            return instructions.cachedValue;
        }
        else {
            return this.processInstrunction(instructions);
        }
    }
    processInstrunction(instructions) {
        switch (instructions.mode) {
            case "class":
                if (instructions.closure != null) {
                    let closure = instructions.closure;
                    let params = this.getParamNames(closure);
                    if (params) {
                        return new closure(...this.injectValues(params));
                    }
                    else {
                        return new closure();
                    }
                }
                else {
                    return instructions.cachedValue;
                }
            case "function":
                if (instructions.closure !== null) {
                    let closure = instructions.closure;
                    let params = this.getParamNames(closure);
                    if (params) {
                        return closure(...this.injectValues(params));
                    }
                    else {
                        return closure();
                    }
                }
                else {
                    return instructions.cachedValue;
                }
            case "value":
                return instructions.closure;
            default:
                break;
        }
    }
    injectValues(params) {
        let injectedParams = [];
        params.forEach((element) => {
            let value = this.entries[element];
            if (value) {
                switch (value.mode) {
                    case "class":
                        if (value.closure != null) {
                            let closure = value.closure;
                            let params = this.getParamNames(closure);
                            if (params) {
                                injectedParams.push(new closure(this.injectValues(params)));
                            }
                            else {
                                injectedParams.push(new closure());
                            }
                        }
                        else {
                            injectedParams.push(value.cachedValue);
                        }
                        break;
                    case "function":
                        if (value.closure != null) {
                            let closure2 = value.closure;
                            let params2 = this.getParamNames(closure2);
                            if (params2) {
                                injectedParams.push(closure2(this.injectValues(params2)));
                            }
                            else {
                                injectedParams.push(closure2());
                            }
                        }
                        else {
                            injectedParams.push(value.cachedValue);
                        }
                        break;
                    case "value":
                        return value.closure;
                    default:
                        break;
                }
            }
            else {
                injectedParams.push(undefined);
            }
        });
        params = injectedParams;
        return params;
    }
    getParamNames(func) {
        let STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
        let ARGUMENT_NAMES = /([^\s,]+)/g;
        let fnStr = func.toString().replace(STRIP_COMMENTS, "");
        let result = fnStr
            .slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")"))
            .match(ARGUMENT_NAMES);
        if (result === null)
            result = [];
        return result;
    }
}
exports.default = Ioc;
