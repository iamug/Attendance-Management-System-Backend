"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ENV_1 = __importDefault(require("../ENV"));
const http_1 = __importDefault(require("http"));
const express_1 = __importDefault(require("express"));
const express_rate_limit_1 = __importDefault(require("express-rate-limit"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const BodyParser_1 = __importDefault(require("../BodyParser"));
//@ts-ignore
const Kernel_1 = __importDefault(require("../../../../App/Http/Kernel"));
const Cors_1 = __importDefault(require("../Cors"));
const Ioc_1 = __importDefault(require("../Container/Ioc"));
const box_1 = __importDefault(require("../Container/box"));
let Ioc = new Ioc_1.default();
box_1.default["Ioc"] = Ioc;
const pathTo = ENV_1.default("PWD");
//@ts-ignore
const app_1 = __importDefault(require("../../../../Config/app"));
let Controllers = [];
let Middlewares = [];
//@ts-ignore
const sockets_1 = __importDefault(require("../../../../Routes/sockets"));
class Boot {
    constructor() {
        this.Ioc = Ioc;
        this.app = express_1.default();
        this.host = ENV_1.default("APP_HOST", "localhost");
        this.port = ENV_1.default("APP_PORT", 8080);
        this.appTP = ENV_1.default("APP_TRANSFER_PROTOCOL", "http");
        this.routes = [];
        this.routePrifix = "";
        this.routeBasePath = `${ENV_1.default("PWD")}/Routes`;
    }
    async start() {
        await this.listen();
    }
    async listen() {
        await this.appInstance();
        await this.load();
        await this.startApp();
        await this.errorHandler();
    }
    async appInstance() {
        await this.Ioc.register("Application", this.app, "value");
        this.Server = http_1.default.createServer(this.app);
        await this.Ioc.register("ApplicationInstance", this.Server, "value");
        await this.autoLoadServiceProviders();
    }
    ThroughDirectory(DirectoryPath, section) {
        fs_1.default.readdirSync(DirectoryPath).forEach((File) => {
            const Absolute = path_1.default.join(DirectoryPath, File);
            if (fs_1.default.statSync(Absolute).isDirectory())
                return this.ThroughDirectory(Absolute, section);
            else {
                switch (section) {
                    case "controller":
                        return Controllers.push(Absolute);
                    case "middleware":
                        return Middlewares.push(Absolute);
                    default:
                        break;
                }
            }
        });
    }
    async autoLoadcontrollers() {
        this.ThroughDirectory(pathTo + "/App/Http/Controller", "controller");
        Controllers.forEach(async (file) => {
            let AFile = path_1.default.parse(file).base;
            let fileName = AFile.split(".").slice(0, -1).join(".");
            let extension = path_1.default.extname(AFile);
            if (extension == ".js" || extension == ".ts") {
                await Promise.resolve().then(() => __importStar(require(file))).then((f) => {
                    this.Ioc.register(fileName, f.default, "class");
                    //@ts-ignore
                    box_1.default["Ioc"].entries = this.Ioc["entries"];
                });
            }
        });
    }
    async autoLoadmiddlewares() {
        this.ThroughDirectory(pathTo + "/App/Http/Middleware", "middleware");
        Middlewares.forEach(async (file) => {
            let AFile = path_1.default.parse(file).base;
            let fileName = AFile.split(".").slice(0, -1).join(".");
            let extension = path_1.default.extname(AFile);
            if (extension == ".js" || extension == ".ts") {
                await Promise.resolve().then(() => __importStar(require(file))).then((f) => {
                    this.Ioc.register(`${fileName}_middleware`, f.default, "class");
                    //@ts-ignore
                    box_1.default["Ioc"].entries = this.Ioc["entries"];
                });
            }
        });
    }
    async autoLoadServiceProviders() {
        if (app_1.default.providers.length > 0) {
            app_1.default.providers.map(async (element) => {
                let data = element.split("/");
                if (data[0] == "Elucidate") {
                    let filesplit = element.split("::");
                    let file = `${filesplit[0]}`;
                    let mode = filesplit[1];
                    let name = file.split("/");
                    let fileName = name[name.length - 1];
                    let filePath = file.replace("Elucidate", "..");
                    await Promise.resolve().then(() => __importStar(require(filePath))).then((f) => {
                        this.Ioc.asProvider(fileName, f.default, mode);
                        //@ts-ignore
                        box_1.default["Ioc"].entries = this.Ioc["entries"];
                    });
                }
                else {
                    let filesplit = element.split("::");
                    let file = `${filesplit[0]}`;
                    let mode = filesplit[1];
                    let name = file.split("/");
                    let fileName = name[name.length - 1];
                    let filePath = pathTo + "/" + file;
                    await Promise.resolve().then(() => __importStar(require(filePath))).then((f) => {
                        this.Ioc.asProvider(fileName, f.default, mode);
                        //@ts-ignore
                        box_1.default["Ioc"].entries = this.Ioc["entries"];
                    });
                }
            });
        }
    }
    async scanRouteDirectory(directory) {
        fs_1.default.readdirSync(directory).forEach((File) => {
            const Absolute = path_1.default.join(directory, File);
            if (fs_1.default.statSync(Absolute).isDirectory())
                return this.scanRouteDirectory(Absolute);
            else {
                return this.routes.push(Absolute);
            }
        });
    }
    //Loads and register route files
    async RegisterRouteFiles() {
        this.routes.forEach((route) => {
            let AFile = path_1.default.parse(route).base;
            let fileName = AFile.split(".").slice(0, -1).join(".");
            let extension = path_1.default.extname(AFile);
            if (fileName !== "sockets") {
                if (extension == ".ts" || extension == ".js") {
                    Promise.resolve().then(() => __importStar(require(route))).then((r) => {
                        this.app.use(`/${this.routePrifix}/`, r.default);
                    });
                }
            }
        });
    }
    loadWSController() {
        sockets_1.default();
    }
    async load() {
        new BodyParser_1.default(this.app);
        this.cors();
        await this.autoLoadcontrollers();
    }
    async startApp() {
        try {
            if (this.Server) {
                await this.bootstrapProviders();
                await this.autoLoadmiddlewares();
                await this.scanRouteDirectory(this.routeBasePath);
                await this.loadGlobalMiddleware();
                await this.RegisterRouteFiles();
                await this.bootedState();
                Ioc = this.Ioc;
                //@ts-ignore
                box_1.default["Ioc"].entries = this.Ioc["entries"];
                this.Server.listen(this.port, () => {
                    console.info(`Application running on ${this.appTP}://${this.host}:${this.port}/${this.routePrifix}`);
                });
            }
        }
        catch (error) {
            throw error;
        }
    }
    async bootedState() {
        for (let key in this.Ioc["entries"]) {
            //@ts-ignore
            let value = this.Ioc["entries"][key];
            if (value.isProvider) {
                let serviceProvicer = value.closure;
                let provider = new serviceProvicer();
                if (key == "RouteServiceProvider") {
                    this.routeConfig(provider);
                }
                else {
                    let methods = this.getAllFunction(provider);
                    if (methods.includes("booted"))
                        provider.booted();
                }
            }
        }
    }
    cors() {
        this.app.use((req, res, next) => {
            Cors_1.default.handle(req, res, next);
        });
    }
    async loadGlobalMiddleware() {
        if (Kernel_1.default.applicationLevelMiddleware.length > 0) {
            Kernel_1.default.applicationLevelMiddleware.map((element) => {
                let data = element.split("/");
                let file = data[data.length - 1];
                let middleware = this.Ioc.use(`${file}_middleware`);
                this.app.use(middleware.handle);
            });
        }
    }
    routeConfig(provider) {
        let routeConfig = provider.boot();
        this.routePrifix = routeConfig.prifix;
        const apiLimiter = express_rate_limit_1.default(routeConfig.limiterConfig);
        this.app.use(routeConfig.specificRoutePrefix, apiLimiter);
    }
    getAllFunction(value) {
        let props = [];
        let obj = value;
        do {
            props = props.concat(Object.getOwnPropertyNames(obj));
        } while ((obj = Object.getPrototypeOf(obj)));
        return props.sort().filter((e, i, arr) => {
            if (e != arr[i + 1] && typeof value[e] == "function")
                return true;
        });
    }
    async bootstrapProviders() {
        for (let key in this.Ioc["entries"]) {
            //@ts-ignore
            let value = this.Ioc["entries"][key];
            if (value.isProvider) {
                let serviceProvicer = value.closure;
                let provider = new serviceProvicer();
                if (key == "RouteServiceProvider") {
                    this.routeConfig(provider);
                }
                else {
                    let methods = this.getAllFunction(provider);
                    if (methods.includes("boot"))
                        provider.boot();
                }
            }
        }
    }
    async errorHandler() {
        this.app.use((error, req, res, next) => {
            if (res.headersSent) {
                return next(error);
            }
            console.log(error.message);
            res
                .status(error.code || 404)
                .json({ message: error.message || "An Unknown Error Occured" });
        });
    }
}
exports.default = new Boot();
