"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongoose_1 = __importDefault(require("mongoose"));
class NOSQLPD_repository {
    constructor(collection) {
        this._collection = collection;
        this.columnName = "id";
        this.order = "asc";
        this.sortBy = {};
        this._id = new mongoose_1.default.Types.ObjectId();
    }
    async getAll(sortBy, paginate) {
        if (sortBy !== undefined) {
            this.columnName = sortBy.columnName;
            this.order = sortBy.order.toLowerCase();
            this.sortBy[`${this.columnName}`] = this.order;
        }
        if (paginate !== undefined) {
            let pageNumber = paginate.pageNumber;
            let dataSize = paginate.dataSize;
            let skipIndex = (pageNumber - 1) * dataSize;
            return await this._collection.estimatedDocumentCount().then((count) => {
                return this._collection
                    .find()
                    .sort(this.sortBy)
                    .limit(dataSize)
                    .skip(skipIndex)
                    .exec()
                    .then((result) => {
                    result.push([{ "total document": count }]);
                    return result;
                })
                    .catch((error) => {
                    return error;
                });
            });
        }
        else {
            return await this._collection
                .find()
                .sort(this.sortBy)
                .exec()
                .then((result) => {
                return result;
            })
                .catch((error) => {
                return error;
            });
        }
    }
    async getAllWhere(args, sortBy, paginate) {
        if (sortBy !== undefined) {
            this.columnName = sortBy.columnName;
            this.order = sortBy.order.toLowerCase();
            this.sortBy[`${this.columnName}`] = this.order;
        }
        if (paginate !== undefined) {
            let pageNumber = paginate.pageNumber;
            let dataSize = paginate.dataSize;
            let skipIndex = (pageNumber - 1) * dataSize;
            return await this._collection.estimatedDocumentCount().then((count) => {
                return this._collection
                    .find(args)
                    .sort(this.sortBy)
                    .limit(dataSize)
                    .skip(skipIndex)
                    .exec()
                    .then((result) => {
                    result.push([{ "total document": count }]);
                    return result;
                })
                    .catch((error) => {
                    return error;
                });
            });
        }
        else {
            return await this._collection
                .find(args)
                .sort(this.sortBy)
                .exec()
                .then((result) => {
                return result;
            })
                .catch((error) => {
                return error;
            });
        }
    }
    async findBy(columnName, item) {
        let searchQuery = {};
        searchQuery[`${columnName}`] = item;
        return await this._collection
            .find(searchQuery)
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async findOne(whereArgs) {
        return await this._collection
            .find(whereArgs)
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async findMany(columnName, pointers) {
        let searchQuery = {};
        searchQuery[`${columnName}`] = pointers;
        return await this._collection
            .find(searchQuery)
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async create(item) {
        item["_id"] = this._id;
        let data = await new this._collection(item);
        return data
            .save()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async updateOne(id, item) {
        mongoose_1.default.set("useFindAndModify", false);
        return await this._collection
            .findOneAndUpdate({ _id: id }, item, {
            new: true,
            upsert: true,
        })
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async updateOneWhere(args, item) {
        mongoose_1.default.set("useFindAndModify", false);
        return await this._collection
            .findOneAndUpdate(args, item, {
            new: true,
            upsert: true,
        })
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async updateMany(columnName, pointers, item) {
        mongoose_1.default.set("useFindAndModify", false);
        let searchQuery = {};
        searchQuery[`${columnName}`] = { $in: pointers };
        return await this._collection
            .updateMany(item, searchQuery, { multi: true })
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async deleteById(id) {
        mongoose_1.default.set("useFindAndModify", false);
        return await this._collection
            .findOneAndRemove({ _id: id })
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async deleteWhere(condition) {
        mongoose_1.default.set("useFindAndModify", false);
        return await this._collection
            .findOneAndRemove(condition)
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
    async deleteMany(columnName, pointers) {
        mongoose_1.default.set("useFindAndModify", false);
        let searchQuery = {};
        searchQuery[`${columnName}`] = { $in: pointers };
        return await this._collection
            .deleteMany(searchQuery)
            .exec()
            .then((result) => {
            return result;
        })
            .catch((error) => {
            return error;
        });
    }
}
exports.default = NOSQLPD_repository;
