"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const QueueManager_1 = __importDefault(require("../Support/QueueManager"));
//@ts-ignore
const queue_ts_1 = __importDefault(require("../../../../Config/queue.ts"));
class ShouldQueue extends QueueManager_1.default {
    constructor() {
        super();
        this.job = null;
        this.signature = "";
        this.connection = this.getConnection(queue_ts_1.default.default);
        if (this.connection == null) {
            throw "Error: Wrong Queue Connection";
        }
        else {
            this.queue = this.connection.queue;
        }
    }
    getConnection(connection) {
        if (connection != null) {
            try {
                return queue_ts_1.default.connections[connection];
            }
            catch (error) {
                console.log(error);
                return null;
            }
        }
        else {
            return null;
        }
    }
    /**
     * Set Queue Signature
     * @param {string} name
     * @return this
     */
    queueSignature(name) {
        this.signature = name;
        return this;
    }
    /**
     * Fire a job
     * @param {*} job
     */
    dispatch(job) {
        this.job = job;
        this.processQueue({ data: this.job, signature: this.signature }, this.queue, this.connection);
        return this;
    }
    /**
     * A helper, that make it easy to only fire a job if a condition is true
     * @param {Boolean} condition
     * @param {*} job
     */
    dispatchIf(condition, job) {
        if (condition) {
            this.dispatch(job);
        }
    }
    /**
     * Set the desired connection for the job.
     */
    onConnection(connection) {
        if (connection != undefined) {
            let result = this.getConnection(connection);
            if (result != null) {
                this.connection = result;
            }
        }
        return this;
    }
    /**
     * Set the desired queue for the job.
     */
    onQueue(queueName) {
        if (queueName != undefined) {
            this.queue = queueName;
        }
        return this;
    }
}
exports.default = ShouldQueue;
