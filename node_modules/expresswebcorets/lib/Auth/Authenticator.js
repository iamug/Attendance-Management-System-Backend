"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
const AuthManager_1 = __importDefault(require("../Support/AuthManager"));
//@ts-ignore
const Hash_1 = __importDefault(require("../Hashing/Hash"));
class Authenticator extends AuthManager_1.default {
    constructor() {
        super(...arguments);
        //@ts-ignore
        this.authOptions = this.authenticatorOptions();
        this.user = null;
    }
    /**
     * Hash Password
     * @param {string} password
     */
    hashPassword(password) {
        return Hash_1.default.make(password);
    }
    /**
     * Generate Token
     * @param {object} user
     */
    generateToken(user) {
        let token = this.sign(user.toJSON(), this.authOptions["secret"], this.authOptions["options"]);
        return token;
    }
    /**
     * Compare Password
     * @param {string} requestPassword | password comming from request body
     * @param {string} databasePassword | password saved in database
     * @return {boolean} Boolean
     */
    comparePassword(requestPassword, databasePassword) {
        let password = Hash_1.default.check(requestPassword, databasePassword);
        return password;
    }
    /**
     * Verify Token
     * @param {String} token
     * @return Promise
     */
    verifyToken(token) {
        return new Promise((resolve, reject) => {
            this.verify(token, this.authOptions["secret"], (err, authorizedData) => {
                if (err)
                    reject(err);
                if (authorizedData)
                    resolve(authorizedData);
            });
        });
    }
    async tryUserModel() {
        if (this.user !== null)
            return this.user;
        try {
            let options = this.authenticatorOptions();
            let model = options.model;
            await Promise.resolve().then(() => __importStar(require(`../../../../App/Model/${model}`))).then((authModel) => {
                this.user = authModel.default;
            });
        }
        catch (error) {
            this.user = null;
        }
    }
    async registerSql(record) {
        await this.tryUserModel();
        try {
            if (this.user !== null) {
                return await this.user
                    .query()
                    .insert(record)
                    .then((saveUser) => {
                    return { error: false, payload: saveUser };
                })
                    .catch((err) => {
                    return {
                        error: true,
                        payload: err,
                        msg: "There was a problem registering the user.",
                    };
                });
            }
            else {
                return {
                    error: true,
                    payload: null,
                    msg: "There was a problem registering the user. This might be related to 'User model'",
                };
            }
        }
        catch (error) {
            return {
                error: true,
                payload: error,
                msg: "There was a problem registering the user.",
            };
        }
    }
    async registerNoSql(record) {
        await this.tryUserModel();
        try {
            if (this.user !== null) {
                const mongoose = require("mongoose");
                record["_id"] = new mongoose.Types.ObjectId();
                return await this.user
                    .create(record)
                    .then((user) => {
                    return { error: false, payload: user };
                })
                    .catch((error) => {
                    return {
                        error: true,
                        payload: error,
                        msg: "There was a problem registering the user.",
                    };
                });
            }
            else {
                return {
                    error: true,
                    payload: null,
                    msg: "There was a problem registering the user. This might be related to 'User model'",
                };
            }
        }
        catch (error) {
            return {
                error: true,
                payload: error,
                msg: "There was a problem registering the user.",
            };
        }
    }
    getValues(record, options) {
        let newRecord = {};
        for (const [key, value] of Object.entries(record)) {
            if (key == options.uid || key == options.password) {
                newRecord[key] = value;
            }
        }
        return newRecord;
    }
    /**
     * Arrange uid and password
     * @param {*} options
     * @param {*} recordData
     */
    uidPw(options, recordData) {
        let uidData = {};
        uidData[options.uid] = recordData[options.uid];
        let pwData = {};
        pwData[options.password] = recordData[options.password];
        return [uidData, pwData];
    }
    async loginSql(record) {
        let options = this.authenticatorOptions();
        let recordData = await this.getValues(record, options);
        await this.tryUserModel();
        if (this.user !== null) {
            let pass = this.uidPw(options, recordData);
            let userRecord = await this.user.query().where(pass[0]).first();
            if (userRecord) {
                let passkey = Object.keys(pass[1]);
                let password = this.comparePassword(recordData[options.password], userRecord[passkey]);
                if (!password) {
                    return { error: true, payload: null, msg: "Wrong login details" };
                }
                else {
                    return { error: false, payload: userRecord };
                }
            }
            else {
                return {
                    error: true,
                    payload: "",
                    msg: "No User Found.",
                };
            }
        }
        else {
            return {
                error: true,
                payload: null,
                msg: "There was a problem registering the user. This might be related to 'User model'",
            };
        }
    }
    async loginNoSql(record) {
        let options = this.authenticatorOptions();
        let recordData = await this.getValues(record, options);
        await this.tryUserModel();
        if (this.user !== null) {
            let pass = this.uidPw(options, recordData);
            return await this.user
                .findOne(pass[0])
                .exec()
                .then((user) => {
                let passkey = Object.keys(pass[1]);
                let password = this.comparePassword(recordData[options.password], user[passkey]);
                if (!password) {
                    let result = {
                        error: true,
                        payload: null,
                        msg: "Wrong login details",
                    };
                    return result;
                }
                else {
                    let result = { error: false, payload: user };
                    return result;
                }
            })
                .catch((error) => {
                return {
                    error: true,
                    payload: error,
                    msg: "No User Found",
                };
            });
        }
        else {
            return {
                error: true,
                payload: null,
                msg: "There was a problem registering the user. This might be related to 'User model'",
            };
        }
    }
    /**
     * Process user registration details
     * @param {object} record
     */
    async processRegistration(record) {
        return process.env.DB_CONNECTION == "mongoose" ? await this.registerNoSql(record) : await this.registerSql(record);
    }
    /**
     * Process user login details
     * @param {object} record
     * @return object
     */
    async innerLoginProcess(record) {
        return process.env.DB_CONNECTION == "mongoose" ? await this.loginNoSql(record) : await this.loginSql(record);
    }
    /**
     * Process user login
     * @param {Array} record
     */
    async processLogin(record) {
        return await new Promise(async (resolve, reject) => {
            let response = await this.innerLoginProcess(record);
            response["error"] ? reject(response) : resolve(response["payload"]);
        });
    }
    /**
     * Create a new user instance
     * @param {object} record
     */
    createUser(record) {
        return new Promise(async (resolve, reject) => {
            let response = await this.processRegistration(record);
            response["error"] ? reject(response) : resolve(response["payload"]);
        });
    }
    /**
     * Process auth middleware
     * @param {string} authorization | req.headers["authorization"]
     */
    processAuthMW(authorization) {
        if (!this.checkAuthorizationHeader(authorization)) {
            return {
                type: "error",
                payload: null,
                msg: "Authorization header mission",
            };
        }
        else {
            const header = authorization;
            if (typeof header !== "undefined") {
                const bearer = header.split(" ");
                const token = bearer[1];
                return this.verifyToken(token)
                    .then((result) => {
                    return { type: "success", payload: result, msg: "Login Successful" };
                })
                    .catch((error) => {
                    return {
                        type: "error",
                        payload: error,
                        msg: "Failed to authenticate token",
                    };
                });
            }
            else {
                return {
                    type: "error",
                    payload: null,
                    msg: "Authentication Failed",
                };
            }
        }
    }
    checkAuthorizationHeader(authorationHeader) {
        return authorationHeader != undefined ? true : false;
    }
}
exports.default = Authenticator;
