"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ArgonHasher_1 = __importDefault(require("../Hashing/ArgonHasher"));
const BcryptHasher_1 = __importDefault(require("../Hashing/BcryptHasher"));
//@ts-ignore
const hashing_1 = __importDefault(require("../../../../Config/hashing"));
class Manager {
    constructor() {
        /**
         * The array of created "drivers".
         *
         * @var array
         */
        this.drivers = ['bcrypt', 'argon'];
    }
    /**
   * Create an instance of the Bcrypt hash Driver.
   *
   * @return \elicidate\Hashing\BcryptHasher
   */
    createBcryptDriver() {
        return new BcryptHasher_1.default(hashing_1.default.bcrypt);
    }
    /**
     * Create an instance of the Argon2i hash Driver.
     *
     * @return \elicidate\Hashing\ArgonHasher
     */
    createArgonDriver() {
        return new ArgonHasher_1.default(hashing_1.default.argon);
    }
    /**
    * Get a driver instance.
    *
    * @param  string|null  $driver
    * @return mixed
    *
    * @throws \InvalidArgumentException
    */
    driver() {
        let driver = this.getDefaultDriver();
        if (driver == null) {
            throw 'Unable to resolve NULL driver for Hashing';
        }
        if (!this.drivers.includes(driver)) {
            throw `Driver ${driver} not supported.`;
        }
        else {
            switch (driver) {
                case 'bcrypt':
                    return this.createBcryptDriver();
                case 'argon':
                    return this.createArgonDriver();
                default:
                    break;
            }
        }
    }
    /**
     * Get the default driver name.
     *
     * @return string
     */
    getDefaultDriver() {
        return hashing_1.default.driver;
    }
}
exports.default = Manager;
